# 인덱스가 무엇일까?
- - -
###### ❗ 해당 글은 제가 공부했던 기억(도서 및 포스트 등)과 개인적 의견이 섞여 작성되었기 때문에 틀리거나 제대로 설명하지 못한 부분이 있을 수 있습니다. 의견 남겨주시면 감사히 여기며 수정하도록 하겠습니다.❗

▶️ [다음글. 표 SQL과 MySQL의 차이점](https://github.com/kkhs00224/mystudy/blob/main/mysql/2_sqlVSmysql.md)   

##  1. 인덱스가 하는 일   
   
*  인덱스는 데이터의 저장(```INSERT```, ```UPDATE```, ```DELETE```)의 성능을 희생하고 그 대신 데이터의 읽기 속도를 높이는, 테이블의 조회 속도를 높여주는 자료구조이다.   
  쉽게 말하면 특정 열 값이 있는 행을 빠르게 찾는데 사용되는 것으로, 인덱스가 있을 경우 테이블의 해당 열에 대한 모든 데이터를 살펴보지 않고도 찾을 위치를 빠르게 결정할 수 있다.   
MySQL에서 사용하는 인덱스의 경우 크게 B-트리 인덱스와 해시 인덱스가 있다.

### 1.1 인덱스가 사용되는 작업
1. ```WHERE```절과 일치하는 행을 찾는 경우
2. 쿼리에 대해 여러 인덱스가 있는 경우, 가장 적은 수의 행을 반환하는 인덱스를 선택한다.
3. 테이블에 다중 열 인덱스가 있는 경우, 인덱스의 가장 왼쪽의 prefix 인덱스가 옵티마이저에 행을 조회하는 데에 사용될 수 있다.
4. ```join```이 수행될 때 다른 테이블에서 행을 검색하려면 데이터 타입(VARCHAR, CHAR 등)이 같고 크기가 같은 경우 사용된다. 예를 들면
   ```mysql
   SELECT * FROM table1 JOIN table2 ON table1.column_name = table2.column_name;
   ```
   위의 예제가 있을 경우 ```on``` 조건의 table1.column_name이 VARCHAR(10)이고, table2.column_name이 VARCHAR(15)라면 크기가 다르기 때문에 인덱스가 사용되지 않는다.
5. ```MIN()``` 또는 ```MAX()``` 값을 찾기 위해 ```WHERE```절에서 조건이 되는 열이 상수인지 확인하기 위해 이전에 발생하는 모든 키를 단일키 조회를 수행해 상수로 대체한 후
쿼리가 한번에 반환된다.
6. 경우에 따라 데이터 행을 참조하지 않고 값을 검색하도록 쿼리를 최적화할 수 있다.   
   
쿼리가 대부분의 행에 접근해야 하는 경우에는 인덱스를 통해 작업하는 것보다 순차적으로 읽는 것이 더 빠르다. 또한 순차 검색은 디스크 검색을 최소화한다. 이를 잘 숙지하고 인덱스를 사용해야 한다.   
인덱스를 사용하지 않는 연산자로는 ```LIKE '%value%'```, ```NOT LIKE '%value%'```, ```REGEXP```, ```NOT REGEXP```, ```!=```, ```<>```, ```IS NULL```, ```IN(NULL,VALUE)```,
```OR```연산자가 있음을 참고하자.

## 2. 인덱스 알고리즘의 종류

### 2.1  B-Tree Index(B-트리 인덱스)
#### B-Tree   
B-트리는 데이터베이스 인덱스에서 널리 사용되는 트리 데이터 구조이다. MySQL의 대부분 인덱스(PRIMARY KEY, UNIQUE, INDEX, FULLTEXT)는 B-트리를 사용한다. 트리의 높이에 따라 약간의 차이가
있을 수 있지만 O(logN)의 시간을 가진다.   
예외적으로 공간 검색의 경우는 R-tree를 사용한다.   

#### 인덱스 확인
```mysql
CREATE TABLE eee (one VARCHAR(100) PRIMARY KEY, two int unique, three char(10)) ENGINE=InnoDB;
SHOW INDEX FROM eee;
```
InnoDB를 사용한 테이블을 만든 후, 해당 테이블의 인덱스를 확인해보면
```
+-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+
| Table | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment | Visible | Expression |
+-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+
| eee   |          0 | PRIMARY  |            1 | one         | A         |           0 |     NULL |   NULL |      | BTREE      |         |               | YES     | NULL       |
| eee   |          0 | two      |            1 | two         | A         |           0 |     NULL |   NULL | YES  | BTREE      |         |               | YES     | NULL       |
+-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+
```
인덱스 타입이 B-Tree이 되어 있는 걸 알 수 있다. 이는 MyISAM 스토리지 엔진도 같다.

#### B-Tree 인덱스의 특성
- B-트리 인덱스는 ```=, >, >=, <, <=``` 비교연산자나 ```BETWEEN``` 연산자에 사용된다. ```LIKE``` 또한 와일드카드 문자로 시작하지 않는 경우 이를 사용한다. 예를 들어,
```mysql
SELECT * FROM table_name WHERE key_col LIKE 'study%';
SELECT * FROM table_name WHERE key_col LIKE 's%dy%';
SELECT * FROM table_name WHERE key_col LIKE '%study%';
```
 세 가지의 ```SELECT``` 구문이 있다고 할 때, 위의 두 구문은 B-Tree 인덱스가 사용되지만, 와일드카드로 감싼 마지막 구문의 경우는 인덱스가 고려되지 않는다.   
만약 '%문자열%'를 사용한다면 문자(characters)가 세 개 이상일 때 MySQL은 Turbo Boyer-Moore 알고리즘을 사용하여 문자열의 패턴을 초기화한 다음 사용해 검색을 더욱 빠르게 수행한다고 한다.   

와일드카드로 감싼 ```LIKE``` 연산자를 사용할 때, 긴 문자의 경우 알고리즘을 통해 문자열을 패턴화해 검색 속도를 돕는다고 하지만, 인덱스가 고려되지 않기 때문에 테이블의 행이 많아질수록 
검색에 더 많은 시간이 걸릴 것으로 생각된다.

- ```AND```연산자를 사용할 때 비교하는 두 조건 모두 혹은 두 조건 중 하나의 컬럼이 인덱스를 사용하지 않는 경우에도 인덱스가 사용되지 않는다.

- 이처럼 경우에 따라 사용 가능한 인덱스가 있더라도 인덱스를 사용하지 않는 경우가 존재한다. 앞선 1.1에서 언급한 연산자들이 그러한 경우에 속하며, 또다른 경우로는 
MySQL의 옵티마이저가 인덱스를 사용하면 테이블의 매우 큰 비율 행에 접근해야 한다고 추정할 때이다. 하지만 이러한 경우더라도 ```LIMIT```를 사용하여 일부 행만 검색하면 몇 개의 행을
빠르게 찾을 수 있기 때문에 인덱스를 사용하게 된다

### 2.2 Hash Index(해시 인덱스)
해시 인덱스는 임의의 길이를 가진 데이터를 고정된 길이의 데이터로 매핑하는 단방향 함수인 해시 함수를 사용해 데이터를 해시 테이블에 저장하는 인덱스를 말한다.   
B-트리 인덱스와 달리 데이터를 정렬된 트리 구조로 저장하지 않기 때문에 일반적으로 메모리 기반의 테이블에서 구현되며, 대용량 테이블 용으로는 거의 사용되지 않는다.

#### 인덱스 확인
```mysql
CREATE TABLE ttt (one VARCHAR(255) PRIMARY KEY, two VARCHAR(10), three int unique) ENGINE=MEMORY;
SHOW INDEX FROM ttt;
```
엔진을 MEMORY로 설정한 후 인덱스를 보면,
```
+-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+
| Table | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment | Visible | Expression |
+-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+
| ttt   |          0 | PRIMARY  |            1 | one         | NULL      |           0 |     NULL |   NULL |      | HASH       |         |               | YES     | NULL       |
| ttt   |          0 | three    |            1 | three       | NULL      |           0 |     NULL |   NULL | YES  | HASH       |         |               | YES     | NULL       |
+-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+
```
인덱스 타입에 'B-Tree'가 아닌 HASH가 적혀있는 걸 볼 수 있다.   
해시 인덱스의 경우 InnoDB와 MyISAM 엔진에서는 사용할 수 없으며, 


#### 해시 인덱스의 특성
-  MyISAM 또는 InnoDB 엔진에서는 사용할 수 없으며 MEMORY, NDB Storage 엔진에서 사용할 수 있다. MEMORY 엔진에서 테이블 생성 시, 해시 인덱스가 기본 인덱스로 생성된다.
- 등호 연산자(=)를 사용하는 정확한 일치 검색에 최적화되어 있고, 범위 검색이나 정렬에는 적합하지 않다. 해시 인덱스는 단일값 조회에 사용되는 키-값 저장소(key-value store) 시스템에서
 사용된다.
- ```ORDER BY``` 작업을 빠르게 수행할 수 없다. 해시 인덱스는 순서대로 다음 항목을 검색하는 데 사용할 수 없다.
- 두 값 사이에 대략적으로 몇 개의 행이 있는지 결정할 수 없다. 그렇기에 범위 최적화기를 사용하지 않는다.
- 행을 검색하기 위해서는 전체 키만 사용할 수 있다. B-트리 인덱스의 경우는 키의 왼쪽 prefix 중 어떤 것이든 행을 찾을 수 있다.

## 3. 인덱스 타입의 종류
관계형 데이터베이스(RDBMS, Relational DataBase Management Service)는 공통적으로 클러스터(PRIMARY) 인덱스와 보조(Secondory) 인덱스로 나뉘어진다.   
MySQL의 경우 InnoDB 엔진에서만 지원이 된다. 따로 설치가 필요한 엔진인 TokuDB에서도 클러스터 인덱스와 보조 인덱스를 사용할 수 있다.   

#### 3.1 클러스터 인덱스와 보조 인덱스의 차이점

두 인덱스를 비교한 표를 [인용](https://inpa.tistory.com/entry/MYSQL-%F0%9F%93%9A-%EC%9D%B8%EB%8D%B1%EC%8A%A4index-%ED%95%B5%EC%8B%AC-%EC%84%A4%EA%B3%84-%EC%82%AC%EC%9A%A9-%EB%AC%B8%EB%B2%95-%F0%9F%92%AF-%EC%B4%9D%EC%A0%95%EB%A6%AC#%EC%9D%B8%EB%8D%B1%EC%8A%A4_%ED%83%80%EC%9E%85_%EC%A2%85%EB%A5%98)해보면,

<table style="boder: 1px solid;">
  <tr>
    <th></th>
    <th>클러스터 인덱스</th>
    <th>보조 인덱스</th>
  </tr>
  <tr>
    <th>속도</th>
    <td>빠르다</td>
    <td>느리다</td>
  </tr>
  <tr>
    <th>사용 메모리</th>
    <td>적다</td>
    <td>많다</td>
  </tr>
  <tr>
    <th>인덱스</th>
    <td>인덱스가 주요 데이터</td>
    <td>인덱스가 데이터의 사본</td>
  </tr>
  <tr>
    <th>개수</th>
    <td>한 테이블에 한 개</td>
    <td>한 테이블에 여러 개(최대 64개)</td>
  </tr>
  <tr>
    <th>리프 노드</th>
    <td>리프 노드 자체가 데이터</td>
    <td>리프 노드는 데이터가 저장되는 위치</td>
  </tr>
  <tr>
    <th>저장값</th>
    <td>데이터를 저장한 블록의 포인터</td>
    <td>값과 데이터의 위치를 가리키는 포인터</td>
  </tr>
  <tr>
    <th>정렬</th>
    <td>인덱스 순서와 물리적 순서가 일치</td>
    <td>인덱스 순서와 물리적 순서가 불치</td>
  </tr>
</table>

표로 두 인덱스의 차이를 정리해볼 수 있다.

#### 3.2 클러스터 인덱스의 생성

클러스터 인덱스와 기본키(PRIMARY KEY)는 동의어이다. 여러 데이터베이스 작업에서 InnoDB가 좋은 성능을 얻으려면 클러스터 인덱스를 사용하여 공통 조회나 DML(데이터 조작어, Data Manipulation Language) 작업을 최적화하는 것이 중요하다.

- 테이블에 ```PRIMARY KEY```를 정의하면 스토리지 엔진에서 이를 자동으로 클러스터 인덱스로 사용한다. 직접 값을 받아도 되고, ```AUTO-INCREMENT```로 만들어도 된다.
- 기본키(대표키)가 정의되지 않으면 모든 키, 열이 ```NOT NULL```로 정의된 첫 번째 ```UNIQUE``` 인덱스를 클러스터 인덱스로 사용한다.
- 만약 기본키와 적합한 유니크 인덱스 둘 다 없는 경우에는 InnoDB가 행 ID값을 포함하는 숨겨진 클러스터 인덱스인 ```GEN_CLUST_INDEX```를 생성한다. 해당 행은 행 ID로 정렬되며,
 새로운 행이 삽입될 때 증가하는 6byte의 필드가 된다. 행 ID로 정렬된 행은 물리적으로 삽입된 순서대로 정렬된다.

#### 3.3 보조 인덱스
- 보조 인덱스의 각 레코드는 행에 대한 기본키의 열과 보조 인덱스에 지정된 열을 모두 포함한다. 기본키 값을 사용해 클러스터 인덱스에서 행을 검색한다.
- 기본키가 길면 보조 인덱스가 더 많은 공간을 사용하기에, 짧은 기본키를 가지는 것이 유리하다.



- - - 
#### 📖 참고문서
*  [MySQL 8.0 참조 설명서](https://dev.mysql.com/doc/refman/8.0/en/)   
*  [B 트리 정의, 위키백과](https://ko.wikipedia.org/wiki/B_%ED%8A%B8%EB%A6%AC)
*  [인덱스 핵심 설계 & 사용문법 총정리](https://inpa.tistory.com/entry/MYSQL-%F0%9F%93%9A-%EC%9D%B8%EB%8D%B1%EC%8A%A4index-%ED%95%B5%EC%8B%AC-%EC%84%A4%EA%B3%84-%EC%82%AC%EC%9A%A9-%EB%AC%B8%EB%B2%95-%F0%9F%92%AF-%EC%B4%9D%EC%A0%95%EB%A6%AC)
